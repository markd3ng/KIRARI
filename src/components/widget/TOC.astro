---
import type { MarkdownHeading } from "astro";
import { siteConfig } from "../../config";
import { url } from "../../utils/url-utils";

interface Props {
	class?: string;
	headings: MarkdownHeading[];
}

let { headings = [] } = Astro.props;

let minDepth = 10;
for (const heading of headings) {
	minDepth = Math.min(minDepth, heading.depth);
}

const className = Astro.props.class;
const isPostsRoute = Astro.url.pathname.startsWith(url("/posts/"));

const removeTailingHash = (text: string) => {
	let lastIndexOfHash = text.lastIndexOf("#");
	if (lastIndexOfHash !== text.length - 1) {
		return text;
	}

	return text.substring(0, lastIndexOfHash);
};

let heading1Count = 1;

const maxLevel = siteConfig.toc.depth;
---
{isPostsRoute &&
<table-of-contents class:list={[className, "group"]}>
    {headings.filter((heading) => heading.depth < minDepth + maxLevel).map((heading) =>
            <a href={`#${heading.slug}`} class="px-2 flex gap-2 relative transition w-full min-h-9 rounded-xl
        hover:bg-[var(--toc-btn-hover)] active:bg-[var(--toc-btn-active)] py-2
    ">
                <div class:list={["transition w-5 h-5 shrink-0 rounded-lg text-xs flex items-center justify-center font-bold",
                    {
                        "bg-[var(--toc-badge-bg)] text-[var(--btn-content)]": heading.depth == minDepth,
                        "ml-4": heading.depth == minDepth + 1,
                        "ml-8": heading.depth == minDepth + 2,
                    }
                ]}
                >
                    {heading.depth == minDepth && heading1Count++}
                    {heading.depth == minDepth + 1 && <div class="transition w-2 h-2 rounded-[0.1875rem] bg-[var(--toc-badge-bg)]"></div>}
                    {heading.depth == minDepth + 2 && <div class="transition w-1.5 h-1.5 rounded-sm bg-black/5 dark:bg-white/10"></div>}
                </div>
                <div class:list={["transition text-sm", {
                    "text-50": heading.depth == minDepth || heading.depth == minDepth + 1,
                    "text-30": heading.depth == minDepth + 2,
                }]}>{removeTailingHash(heading.text)}</div>
            </a>
    )}
    <div id="active-indicator" style="opacity: 0" class:list={[{'hidden': headings.length == 0}, "-z-10 absolute bg-[var(--toc-btn-hover)] left-0 right-0 rounded-xl transition-all " +
        "group-hover:bg-transparent border-2 border-[var(--toc-btn-hover)] group-hover:border-[var(--toc-btn-active)] border-dashed"]}></div>
</table-of-contents>}

<script>
class TableOfContents extends HTMLElement {
    tocEl: HTMLElement | null = null;
    visibleClass = "visible";
    observer: IntersectionObserver;
    anchorNavTarget: HTMLElement | null = null;
    headingIdxMap = new Map<string, number>();
    headings: HTMLElement[] = [];
    sections: HTMLElement[] = [];
    tocEntries: HTMLAnchorElement[] = [];
    active: boolean[] = [];
    scrollCorrectionTimers: number[] = [];
    resizeObserver: ResizeObserver | null = null;
    scrollAnimationId: number = 0;
    activeIndicator: HTMLElement | null = null;
    updatePending = false;
    prevActiveMin = -1;
    prevActiveMax = -1;
    activeCount = 0;

    constructor() {
        super();
        this.observer = new IntersectionObserver(
            this.markVisibleSection, { threshold: 0 }
        );
    };

    markVisibleSection = (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
            const id = entry.target.children[0]?.getAttribute("id");
            const idx = id ? this.headingIdxMap.get(id) : undefined;
            if (idx != undefined) {
                const was = this.active[idx];
                const now = entry.isIntersecting;
                if (was !== now) {
                    this.active[idx] = now;
                    this.activeCount += now ? 1 : -1;
                }
            }

            if (entry.isIntersecting && this.anchorNavTarget == entry.target.firstChild)
                this.anchorNavTarget = null;
        });

        if (this.activeCount <= 0)
            this.fallback();
        this.update();
    };

    toggleActiveHeading = () => {
        let i = this.active.length - 1;
        let min = this.active.length - 1, max = -1;
        while (i >= 0 && !this.active[i]) i--;
        while (i >= 0 && this.active[i]) {
            min = Math.min(min, i);
            max = Math.max(max, i);
            i--;
        }

        // Skip DOM updates if active range unchanged
        if (min === this.prevActiveMin && max === this.prevActiveMax) return false;
        this.prevActiveMin = min;
        this.prevActiveMax = max;

        for (let j = 0; j < this.tocEntries.length; j++) {
            if (j >= min && j <= max) {
                this.tocEntries[j].classList.add(this.visibleClass);
            } else {
                this.tocEntries[j].classList.remove(this.visibleClass);
            }
        }

        if (min > max) {
            this.activeIndicator?.setAttribute("style", `opacity: 0`);
        } else {
            let parentOffset = this.tocEl?.getBoundingClientRect().top || 0;
            let scrollOffset = this.tocEl?.scrollTop || 0;
            let top = this.tocEntries[min].getBoundingClientRect().top - parentOffset + scrollOffset;
            let bottom = this.tocEntries[max].getBoundingClientRect().bottom - parentOffset + scrollOffset;
            this.activeIndicator?.setAttribute("style", `top: ${top}px; height: ${bottom - top}px`);
        }
        return true;
    };

    scrollToActiveHeading = () => {
        // If the TOC widget can accommodate both the topmost
        // and bottommost items, scroll to the topmost item.
        // Otherwise, scroll to the bottommost one.

        if (this.anchorNavTarget || !this.tocEl) return;
        const min = this.prevActiveMin;
        const max = this.prevActiveMax;
        if (min < 0 || max < 0 || min > max) return;

        const topmost = this.tocEntries[min];
        const bottommost = this.tocEntries[max];
        const tocHeight = this.tocEl.clientHeight;

        let top;
        if (bottommost.getBoundingClientRect().bottom -
            topmost.getBoundingClientRect().top < 0.9 * tocHeight)
            top = topmost.offsetTop - 32;
        else
            top = bottommost.offsetTop - tocHeight * 0.8;

        this.tocEl.scrollTo({
            top,
            left: 0,
            behavior: "smooth",
        });
    };

    update = () => {
        if (this.updatePending) return;
        this.updatePending = true;
        requestAnimationFrame(() => {
            this.updatePending = false;
            if (this.toggleActiveHeading()) {
                this.scrollToActiveHeading();
            }
        });
    };

    fallback = () => {
        if (!this.sections.length) return;

        for (let i = 0; i < this.sections.length; i++) {
            const rect = this.sections[i].getBoundingClientRect();

            if (this.isInRange(rect.top, 0, window.innerHeight)
                || this.isInRange(rect.bottom, 0, window.innerHeight)
                || (rect.top < 0 && rect.bottom > window.innerHeight)) {
                this.markActiveHeading(i);
            }
            else if (rect.top > window.innerHeight) break;
        }
    };

    markActiveHeading = (idx: number)=> {
        this.active[idx] = true;
    };

    // Fast animated scroll with easeOutCubic.
    // Native smooth scroll is ~500ms and can't be configured.
    // We disable CSS scroll-behavior during the animation so our
    // per-frame scrollTop assignments aren't intercepted by the browser.
    fastScrollTo = (target: HTMLElement) => {
        cancelAnimationFrame(this.scrollAnimationId);
        const distance = target.getBoundingClientRect().top;
        // For very short distances, just jump instantly
        if (Math.abs(distance) < 4) return;
        const duration = 250;
        const start = performance.now();
        // Determine the scroll container (OverlayScrollbars viewport or fallback)
        const bodyEl = document.querySelector('body');
        const os = bodyEl && (window as any).OverlayScrollbars?.(bodyEl);
        const scroller = os ? os.elements().viewport : document.documentElement;
        const startPos = scroller.scrollTop;
        // Disable CSS scroll-behavior so scrollTop is applied instantly per frame
        document.documentElement.style.scrollBehavior = 'auto';
        const step = (now: number) => {
            const elapsed = now - start;
            const t = Math.min(elapsed / duration, 1);
            // easeOutCubic: fast start, gentle stop
            const ease = 1 - Math.pow(1 - t, 3);
            scroller.scrollTop = startPos + distance * ease;
            if (t < 1) {
                this.scrollAnimationId = requestAnimationFrame(step);
            } else {
                // Restore CSS scroll-behavior after animation completes
                document.documentElement.style.removeProperty('scroll-behavior');
            }
        };
        this.scrollAnimationId = requestAnimationFrame(step);
    };

    handleAnchorClick = (event: Event) => {
        const anchor = event
            .composedPath()
            .find((element) => element instanceof HTMLAnchorElement);

        if (anchor) {
            const id = decodeURIComponent(anchor.hash?.substring(1));
            const idx = this.headingIdxMap.get(id);
            if (idx !== undefined) {
                event.preventDefault(); // Only prevent default if we can handle the scroll
                this.anchorNavTarget = this.headings[idx];
                // Cancel any pending scroll corrections from a previous click
                this.scrollCorrectionTimers.forEach(clearTimeout);
                this.scrollCorrectionTimers = [];
                this.resizeObserver?.disconnect();
                this.resizeObserver = null;

                const heading = this.headings[idx];
                if (heading) {
                    // Force all content-visibility:auto elements to render at
                    // actual heights so scroll positions are accurate.
                    const mdContainer = document.querySelector('.custom-md');
                    if (mdContainer) mdContainer.classList.add('cv-force-visible');

                    this.fastScrollTo(heading);
                    // Correct scroll if async content (expressive code, LaTeX,
                    // tables, images) renders and shifts element positions.
                    const correctScroll = () => {
                        if (Math.abs(heading.getBoundingClientRect().top) > 2) {
                            heading.scrollIntoView({ behavior: 'instant', block: 'start' });
                        }
                    };
                    // ResizeObserver reacts instantly to any layout shift
                    const heavyElements = document.querySelectorAll<HTMLElement>('.expressive-code, .katex-display');
                    this.resizeObserver = new ResizeObserver(() => correctScroll());
                    heavyElements.forEach(el => this.resizeObserver!.observe(el));
                    // Timed fallbacks for shifts not caught by ResizeObserver
                    this.scrollCorrectionTimers.push(
                        setTimeout(correctScroll, 800) as unknown as number,
                        setTimeout(correctScroll, 1500) as unknown as number,
                        setTimeout(() => {
                            this.resizeObserver?.disconnect();
                            this.resizeObserver = null;
                            // Restore content-visibility:auto for performance
                            if (mdContainer) mdContainer.classList.remove('cv-force-visible');
                        }, 10000) as unknown as number,
                    );
                }
            }
            // If heading not found in map, let default browser anchor behavior handle it
        }
    };

    isInRange(value: number, min: number, max: number) {
        return min < value && value < max;
    };

    connectedCallback() {
        // Wait for the onload animation to finish so getBoundingClientRect
        // returns correct values. The animation is on #content-wrapper (not
        // .prose), so we listen there. animationend bubbles UP, so listening
        // on a descendant like .prose would never catch it.
        const contentWrapper = document.getElementById('content-wrapper');
        if (contentWrapper) {
            const tryInit = () => {
                if (!this.tocEl) this.init();
            };
            contentWrapper.addEventListener('animationend', tryInit, { once: true });
            // Fallback: if animation was already stripped (hash navigation,
            // subsequent page loads) or finished before this runs, init after
            // a short delay matching the animation duration.
            setTimeout(tryInit, 500);
        } else {
            // No content wrapper (e.g. non-post page), try init immediately
            this.init();
        }
    };

    // Create (or recreate) the IntersectionObserver with the correct root.
    // When OverlayScrollbars is active, the scroll container is the OS viewport,
    // not the document. Chrome requires the observer root to match the actual
    // scroll container; otherwise it stops firing on scroll.
    setupObserver() {
        this.observer.disconnect();
        const bodyEl = document.querySelector('body');
        const os = bodyEl ? (window as any).OverlayScrollbars?.(bodyEl) : null;
        this.observer = new IntersectionObserver(
            this.markVisibleSection,
            { threshold: 0, root: os ? os.elements().viewport : null }
        );
        this.sections.forEach((section) => {
            if (section) this.observer.observe(section);
        });
    };

    init() {
        this.tocEl = document.getElementById(
            "toc-inner-wrapper"
        );

        if (!this.tocEl) return;

        this.tocEl.addEventListener("click", this.handleAnchorClick, {
            capture: true,
        });

        this.activeIndicator = document.getElementById("active-indicator");

        this.tocEntries = Array.from(
            document.querySelectorAll<HTMLAnchorElement>("#toc a[href^='#']")
        );

        if (this.tocEntries.length === 0) return;

        this.sections = new Array(this.tocEntries.length);
        this.headings = new Array(this.tocEntries.length);
        for (let i = 0; i < this.tocEntries.length; i++) {
            const id = decodeURIComponent(this.tocEntries[i].hash?.substring(1));
            const heading = document.getElementById(id);
            const section = heading?.parentElement;
            if (heading instanceof HTMLElement && section instanceof HTMLElement) {
                this.headings[i] = heading;
                this.sections[i] = section;
                this.headingIdxMap.set(id, i);
            }
        }
        this.active = new Array(this.tocEntries.length).fill(false);

        this.setupObserver();

        // On initial page load, OverlayScrollbars initializes at ~600ms
        // (after init runs at ~400-500ms). Re-create the observer once
        // OS is ready so the root points to the actual scroll container.
        const bodyEl = document.querySelector('body');
        const os = bodyEl ? (window as any).OverlayScrollbars?.(bodyEl) : null;
        if (!os) {
            setTimeout(() => {
                this.setupObserver();
                this.fallback();
                this.update();
            }, 700);
        }

        this.fallback();
        this.update();
    };

    disconnectedCallback() {
        this.sections.forEach((section) =>
            this.observer.unobserve(section)
        );
        this.observer.disconnect();
        this.tocEl?.removeEventListener("click", this.handleAnchorClick);
    };
}

if (!customElements.get("table-of-contents")) {
    customElements.define("table-of-contents", TableOfContents);
}
</script>